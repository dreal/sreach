// The longitudinal position of the car along the road is denoted by x1, and 
// its velocity by x2 (lateral dynamics are ignored)
// The model has the control u = (gear, v), 
// where gear \in {1, 2, 3, 4} denotes the gear position, and 
// v \in [v_min, v_max] the throttle position.
// Gear shift is necessary because little power can be generated by the engine at very
// low or very high engine speed. 
// The function alpha_i represents the efficiency of gear i

// Note:
// in this model, density function of normal distributions are used as alpha(x2) functions

//#define mu1 1 // \in (0.5, 1.5)
//#define mu2 1.8 // \in (1.5, 2.5)
//#define mu3 2.8 // \in (2.5, 3.5)
//#define mu4 3.8 // \in (3.5, 4.5)

//#define theta1 0.5 // \in (0.3, 0.7)
//#define theta2 0.5 // \in (0.3, 0.7)
//#define theta3 0.52 // \in (0.3, 0.7)
//#define theta4 0.43 // \in (0.3, 0.7)

#define x1init 0 // initial location
#define x2init 1 // initial velocity
//U(2, 4) x2init;

//#define thre1 10 // threshold 1 for shifting
//N(2, 0.0001) thre1;
#define thre1 1.5
#define diff 0.5
#define thre2 (thre1 + diff) // threshold 2 for shifting
#define thre3 (thre2 + diff) // threshold 3 for shifting
#define thre4 (thre3 + diff) // threshold 4 for shifting
#define pi 3.1416


N(1, 0.0001) mu1;
N(1.7, 0.0001) mu2;
N(3.5, 0.0001) mu3;
N(4, 0.0001) mu4;
U(0.49, 0.51) theta1;
U(0.49, 0.51) theta2;
U(0.49, 0.51) theta3;
U(0.49, 0.51) theta4;
// throttle
U(10, 11) thro; 

[0, 1000] x1;
[0, 1000] x2;
[0, 3] time;




{ mode 1; //gear 1

  invt:
        
  flow:
        d/dt[x1] = x2;
	d/dt[x2] = thro * (1 / (theta1 * sqrt(2 * pi))) * exp(0 - ((x2 - mu1) ^ 2) / (2 * theta1 ^ 2));
  jump:
        (x2 >= thre2) ==> @2 (and (x1' = x1) (x2' = x2));
}
{ mode 2; //gear 2

  invt:
          
  flow:
        d/dt[x1] = x2;
	d/dt[x2] = thro * (1 / (theta2 * sqrt(2 * pi))) * exp(0 - ((x2 - mu2) ^ 2) / (2 * theta2 ^ 2));
  jump:
        (x2 >= thre3) ==> @3 (and (x1' = x1) (x2' = x2));
	(x2 <= thre1) ==> @1 (and (x1' = x1) (x2' = x2));
}
{ mode 3; //gear 3

  invt:
        
  flow:
        d/dt[x1] = x2;
	d/dt[x2] = thro * (1 / (theta3 * sqrt(2 * pi))) * exp(0 - ((x2 - mu3) ^ 2) / (2 * theta3 ^ 2));
  jump:
        (x2 >= thre4) ==> @4 (and (x1' = x1) (x2' = x2));
	(x2 <= thre2) ==> @2 (and (x1' = x1) (x2' = x2));
}
{ mode 4; //gear 4

  invt:
        
  flow:
        d/dt[x1] = x2;
	d/dt[x2] = thro * (1 / (theta4 * sqrt(2 * pi))) * exp(0 - ((x2 - mu4) ^ 2) / (2 * theta4 ^ 2));
  jump:
        (x2 <= thre3) ==> @3 (and (x1' = x1) (x2' = x2));
}
init:
@1	(and (x1 = x1init) (x2 = x2init));

goal:
//@4	(and (gear <= 5) (x2 = x2init));
//@4      (or (gear >= 5) (x2 >= 80));
@3     (x2 >= thre4);
//@2    (x2 <= thre1);
