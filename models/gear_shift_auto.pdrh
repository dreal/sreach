// The longitudinal position of the car along the road is denoted by x1, and 
// its velocity by x2 (lateral dynamics are ignored)
// The model has the control u = (gear, v), 
// where gear \in {1, 2, 3, 4} denotes the gear position, and 
// v \in [v_min, v_max] the throttle position.
// Gear shift is necessary because little power can be generated by the engine at very
// low or very high engine speed. 
// The function alpha_i represents the efficiency of gear i

// Note:
// in this model, density function of normal distributions are used as alpha(x2) functions

#define mu1 0.8 // \in (0.5, 1.5)
#define mu2 1.8 // \in (1.5, 2.5)
#define mu3 2.8 // \in (2.5, 3.5)
#define mu4 3.8 // \in (3.5, 4.5)
#define theta1 0.4 // \in (0.3, 0.7)
#define theta2 0.5 // \in (0.3, 0.7)
#define theta3 0.52 // \in (0.3, 0.7)
#define theta4 0.43 // \in (0.3, 0.7)
#define x1init 0 // initial location
#define x2init 3 // initial velocity
#define thre1 10 // threshold 1 for shifting
#define thre2 15 // threshold 2 for shifting
#define thre3 20 // threshold 3 for shifting
#define thre4 25 // threshold 4 for shifting
#define pi 3.1416
 
[0, 1] v; // throttle
[0, 5] gear; // necessary?
[0, 1000] x1;
[0, 100] x2;
[0, 3] t;



{ mode 1; //gear 1

  invt:
        (gear <= 1.5);
	(gear > 0);
  flow:
        d/dt[x1] = x2;
	d/dt[x2] = v * (1 / (theta1 * sqrt(2 * pi))) * exp(0 - ((x2 - mu1) ^ 2) / (2 * theta1 ^ 2));
	d/dt[gear] = 0.0;
  jump:
        (x2 >= thre2) ==> @2 (and (gear' = gear + 1) (x1' = x1) (x2' = x2));
}
{ mode 2; //gear 2

  invt:
        (gear > 1);
	(gear <= 2.5);
  flow:
        d/dt[x1] = x2;
	d/dt[x2] = v * (1 / (theta2 * sqrt(2 * pi))) * exp(0 - ((x2 - mu2) ^ 2) / (2 * theta2 ^ 2));
	d/dt[gear] = 0.0;
  jump:
        (x2 >= thre3) ==> @3 (and (gear' = gear + 1) (x1' = x1) (x2' = x2));
	(x2 <= thre1) ==> @1 (and (gear' = gear - 1) (x1' = x1) (x2' = x2));
}
{ mode 3; //gear 3

  invt:
        (gear <= 3.5); 
	(gear > 2);
  flow:
        d/dt[x1] = x2;
	d/dt[x2] = v * (1 / (theta3 * sqrt(2 * pi))) * exp(0 - ((x2 - mu3) ^ 2) / (2 * theta3 ^ 2));
	d/dt[gear] = 0.0;
  jump:
        (x2 >= thre4) ==> @4 (and (gear' = gear + 1) (x1' = x1) (x2' = x2));
	(x2 <= thre2) ==> @2 (and (gear' = gear - 1) (x1' = x1) (x2' = x2));
}
{ mode 4; //gear 4

  invt:
        (gear <= 4.5);
	(gear > 3);
  flow:
        d/dt[x1] = x2;
	d/dt[x2] = v * (1 / (theta4 * sqrt(2 * pi))) * exp(0 - ((x2 - mu4) ^ 2) / (2 * theta4 ^ 2));
	d/dt[gear] = 0.0;
  jump:
        (x2 <= thre3) ==> @3 (and (gear' = gear - 1) (x1' = x1) (x2' = x2));
}
init:
@1	(and (x1 = x1init) (x2 = x2init) (gear = 1));

goal:
@3	(and (gear <= 5) (x2 <= 80));
